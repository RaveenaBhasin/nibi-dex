/**
* This file was automatically generated by @cosmwasm/ts-codegen@0.35.7.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { CosmWasmClient, SigningCosmWasmClient, ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { Coin, StdFee } from "@cosmjs/amino";
import { Uint128, Logo, EmbeddedLogo, Binary, TokenInfo, Addr, InstantiateMsg, InstantiateMsg1, Cw20Coin, InstantiateMarketingInfo, MinterResponse, ExecuteMsg, Cw20ExecuteMsg, Expiration, Timestamp, Uint64, Token, QueryMsg, QueryMsg1, ArraySize_2OfToken, PairInfo } from "./Pair.types";
export interface PairReadOnlyInterface {
  contractAddress: string;
  poolInfo: () => Promise<PairInfo>;
  tokenQuery: (queryMsg: QueryMsg) => Promise<QueryMsg>;
  getEstimatedLpAmount: ({
    assets
  }: {
    assets: Token[];
  }) => Promise<Uint128>;
  getAmountOut: ({
    amountIn,
    fromToken,
    toToken
  }: {
    amountIn: number;
    fromToken: TokenInfo;
    toToken: TokenInfo;
  }) => Promise<Uint128>;
  getEstimatedTokenAmounts: ({
    lpTokenAmount
  }: {
    lpTokenAmount: Uint128;
  }) => Promise<ArraySize2OfToken>;
  getReserves0: () => Promise<Uint128>;
  getReserves1: () => Promise<Uint128>;
}
export class PairQueryClient implements PairReadOnlyInterface {
  client: CosmWasmClient;
  contractAddress: string;

  constructor(client: CosmWasmClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.poolInfo = this.poolInfo.bind(this);
    this.tokenQuery = this.tokenQuery.bind(this);
    this.getEstimatedLpAmount = this.getEstimatedLpAmount.bind(this);
    this.getAmountOut = this.getAmountOut.bind(this);
    this.getEstimatedTokenAmounts = this.getEstimatedTokenAmounts.bind(this);
    this.getReserves0 = this.getReserves0.bind(this);
    this.getReserves1 = this.getReserves1.bind(this);
  }

  poolInfo = async (): Promise<PairInfo> => {
    return this.client.queryContractSmart(this.contractAddress, {
      pool_info: {}
    });
  };
  tokenQuery = async (queryMsg: QueryMsg): Promise<QueryMsg> => {
    return this.client.queryContractSmart(this.contractAddress, {
      token_query: queryMsg
    });
  };
  getEstimatedLpAmount = async ({
    assets
  }: {
    assets: Token[];
  }): Promise<Uint128> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_estimated_lp_amount: {
        assets
      }
    });
  };
  getAmountOut = async ({
    amountIn,
    fromToken,
    toToken
  }: {
    amountIn: number;
    fromToken: TokenInfo;
    toToken: TokenInfo;
  }): Promise<Uint128> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_amount_out: {
        amount_in: amountIn,
        from_token: fromToken,
        to_token: toToken
      }
    });
  };
  getEstimatedTokenAmounts = async ({
    lpTokenAmount
  }: {
    lpTokenAmount: Uint128;
  }): Promise<ArraySize2OfToken> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_estimated_token_amounts: {
        lp_token_amount: lpTokenAmount
      }
    });
  };
  getReserves0 = async (): Promise<Uint128> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_reserves0: {}
    });
  };
  getReserves1 = async (): Promise<Uint128> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_reserves1: {}
    });
  };
}
export interface PairInterface extends PairReadOnlyInterface {
  contractAddress: string;
  sender: string;
  swapAsset: ({
    amountIn,
    fromToken,
    minAmountOut,
    toToken
  }: {
    amountIn: number;
    fromToken: TokenInfo;
    minAmountOut: number;
    toToken: TokenInfo;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  addLiquidity: ({
    assets,
    minLiquidityAmt
  }: {
    assets: Token[];
    minLiquidityAmt: Uint128;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  removeLiquidity: ({
    lpTokenAmount
  }: {
    lpTokenAmount: Uint128;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  tokenExecute: (cw20ExecuteMsg: Cw20ExecuteMsg, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
}
export class PairClient extends PairQueryClient implements PairInterface {
  client: SigningCosmWasmClient;
  sender: string;
  contractAddress: string;

  constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string) {
    super(client, contractAddress);
    this.client = client;
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.swapAsset = this.swapAsset.bind(this);
    this.addLiquidity = this.addLiquidity.bind(this);
    this.removeLiquidity = this.removeLiquidity.bind(this);
    this.tokenExecute = this.tokenExecute.bind(this);
  }

  swapAsset = async ({
    amountIn,
    fromToken,
    minAmountOut,
    toToken
  }: {
    amountIn: number;
    fromToken: TokenInfo;
    minAmountOut: number;
    toToken: TokenInfo;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      swap_asset: {
        amount_in: amountIn,
        from_token: fromToken,
        min_amount_out: minAmountOut,
        to_token: toToken
      }
    }, fee, memo, _funds);
  };
  addLiquidity = async ({
    assets,
    minLiquidityAmt
  }: {
    assets: Token[];
    minLiquidityAmt: Uint128;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      add_liquidity: {
        assets,
        min_liquidity_amt: minLiquidityAmt
      }
    }, fee, memo, _funds);
  };
  removeLiquidity = async ({
    lpTokenAmount
  }: {
    lpTokenAmount: Uint128;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      remove_liquidity: {
        lp_token_amount: lpTokenAmount
      }
    }, fee, memo, _funds);
  };
  tokenExecute = async (cw20ExecuteMsg: Cw20ExecuteMsg, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      token_execute: cw20ExecuteMsg
    }, fee, memo, _funds);
  };
}